#!/usr/bin/env python3
"""
IoT Device Emulator for Palo Alto SD-WAN/IoT Security Lab
Generates ARP, DHCP, MQTT, HTTP, RTSP traffic to simulate real IoT devices
"""

import json
import sys
import time
import threading
import logging
import argparse
from datetime import datetime
from pathlib import Path
from scapy.all import (
    Ether, IP, UDP, TCP, DHCP, ARP, Raw,
    sendp, send, conf
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('iot_emulator.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class IoTDevice:
    """Base class for IoT device simulation"""
    
    def __init__(self, device_config, interface="eth0"):
        self.id = device_config.get("id")
        self.name = device_config.get("name")
        self.vendor = device_config.get("vendor")
        self.device_type = device_config.get("type")
        self.mac = device_config.get("mac")
        self.ip = device_config.get("ip_start")
        self.protocols = device_config.get("protocols", [])
        self.enabled = device_config.get("enabled", True)
        self.traffic_interval = device_config.get("traffic_interval", 60)
        self.mqtt_topic = device_config.get("mqtt_topic")
        self.interface = interface
        self.gateway = "192.168.207.1"
        self.running = False
        
    def __repr__(self):
        return f"[{self.vendor}] {self.name} ({self.ip})"
    
    def start(self):
        """Start device emulation threads"""
        if not self.enabled:
            logger.warning(f"Device {self} is disabled, skipping")
            return
        
        self.running = True
        logger.info(f"üöÄ Starting device: {self}")
        
        # Start protocol-specific threads
        for protocol in self.protocols:
            thread = threading.Thread(
                target=self._protocol_handler,
                args=(protocol,),
                daemon=True
            )
            thread.start()
    
    def stop(self):
        """Stop device emulation"""
        self.running = False
        logger.info(f"‚èπÔ∏è  Stopped device: {self}")
    
    def _protocol_handler(self, protocol):
        """Route to protocol handler"""
        handlers = {
            "arp": self.send_arp,
            "dhcp": self.send_dhcp,
            "http": self.send_http,
            "mqtt": self.send_mqtt,
            "rtsp": self.send_rtsp,
            "mdns": self.send_mdns,
        }
        
        handler = handlers.get(protocol)
        if handler:
            handler()
        else:
            logger.warning(f"Unknown protocol: {protocol}")
    
    def send_arp(self):
        """Send ARP requests (device discovery)"""
        logger.debug(f"üîç ARP thread started for {self.id}")
        
        while self.running:
            try:
                # ARP who-has request
                pkt = Ether(dst="ff:ff:ff:ff:ff:ff", src=self.mac) / \
                      ARP(op="who-has", 
                          pdst=self.gateway, 
                          hwsrc=self.mac, 
                          psrc=self.ip)
                
                sendp(pkt, iface=self.interface, verbose=0)
                logger.debug(f"üì§ ARP request from {self.id}: {self.ip} ({self.mac})")
                
            except Exception as e:
                logger.error(f"‚ùå ARP error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval)
    
    def send_dhcp(self):
        """Send DHCP Discovery packets"""
        logger.debug(f"üîç DHCP thread started for {self.id}")
        
        while self.running:
            try:
                # DHCP Discover packet
                pkt = Ether(dst="ff:ff:ff:ff:ff:ff", src=self.mac) / \
                      IP(src="0.0.0.0", dst="255.255.255.255") / \
                      UDP(sport=68, dport=67) / \
                      DHCP(options=[
                          ("message-type", "discover"),
                          ("client_id", self.mac),
                          ("host_name", self.name),
                          ("end")
                      ])
                
                sendp(pkt, iface=self.interface, verbose=0)
                logger.debug(f"üì§ DHCP Discover from {self.id}: {self.name}")
                
            except Exception as e:
                logger.error(f"‚ùå DHCP error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval * 2)
    
    def send_http(self):
        """Send HTTP requests (configuration/status check)"""
        logger.debug(f"üåê HTTP thread started for {self.id}")
        
        while self.running:
            try:
                # HTTP GET to gateway (simulating status check)
                pkt = IP(src=self.ip, dst=self.gateway) / \
                      TCP(dport=80, flags="S")
                
                send(pkt, verbose=0)
                logger.debug(f"üì§ HTTP SYN from {self.id} to {self.gateway}:80")
                
            except Exception as e:
                logger.error(f"‚ùå HTTP error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval)
    
    def send_mqtt(self):
        """Send MQTT publish packets (for sensors)"""
        logger.debug(f"üí¨ MQTT thread started for {self.id}")
        
        mqtt_broker = "192.168.207.150"
        
        while self.running:
            try:
                # MQTT Connect SYN
                pkt = IP(src=self.ip, dst=mqtt_broker) / \
                      TCP(dport=1883, flags="S")
                
                send(pkt, verbose=0)
                logger.debug(f"üì§ MQTT Connect from {self.id} to {mqtt_broker}:1883")
                
                time.sleep(5)
                
            except Exception as e:
                logger.error(f"‚ùå MQTT error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval)
    
    def send_rtsp(self):
        """Send RTSP requests (for cameras)"""
        logger.debug(f"üé• RTSP thread started for {self.id}")
        
        while self.running:
            try:
                # RTSP SETUP/PLAY to gateway
                pkt = IP(src=self.ip, dst=self.gateway) / \
                      TCP(dport=554, flags="S")
                
                send(pkt, verbose=0)
                logger.debug(f"üì§ RTSP SYN from {self.id} to {self.gateway}:554")
                
            except Exception as e:
                logger.error(f"‚ùå RTSP error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval)
    
    def send_mdns(self):
        """Send mDNS requests (for discovery)"""
        logger.debug(f"üîé mDNS thread started for {self.id}")
        
        while self.running:
            try:
                # mDNS query (UDP 5353)
                pkt = IP(src=self.ip, dst="224.0.0.251") / \
                      UDP(sport=5353, dport=5353)
                
                send(pkt, verbose=0)
                logger.debug(f"üì§ mDNS query from {self.id}")
                
            except Exception as e:
                logger.error(f"‚ùå mDNS error for {self.id}: {e}")
            
            time.sleep(self.traffic_interval * 3)


class IoTEmulator:
    """Main emulator controller"""
    
    def __init__(self, config_file, interface="eth0"):
        self.config_file = Path(config_file)
        self.interface_cli = interface
        self.interface = interface
        self.devices = []
        self.threads = []
        
        # Verify we're running with proper permissions
        if conf.route is None:
            logger.error("‚ö†Ô∏è  Scapy requires root/sudo permissions!")
            sys.exit(1)
        
        logger.info("=" * 60)
        logger.info("üöÄ IoT Emulator for Palo Alto SD-WAN/IoT Security Lab")
        logger.info("=" * 60)
    
    def load_config(self):
        """Load device configuration from JSON"""
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
            
            logger.info(f"‚úÖ Loaded config from {self.config_file}")
            
            # Extract network settings
            network = config.get("network", {})
            
            # CLI argument takes priority over JSON config
            if self.interface_cli == "eth0" and "interface" in network:
                self.interface = network.get("interface")
                logger.info(f"üì° Using interface from config: {self.interface}")
            else:
                logger.info(f"üì° Using interface from CLI: {self.interface}")
            
            self.gateway = network.get("gateway", "192.168.207.1")
            
            # Create device objects
            for device_config in config.get("devices", []):
                device = IoTDevice(device_config, interface=self.interface)
                device.gateway = self.gateway
                self.devices.append(device)
            
            logger.info(f"‚úÖ Loaded {len(self.devices)} devices")
            for device in self.devices:
                status = "‚úÖ enabled" if device.enabled else "‚è∏Ô∏è  disabled"
                logger.info(f"   {device} - {status}")
            
        except FileNotFoundError:
            logger.error(f"‚ùå Config file not found: {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Invalid JSON in config: {e}")
            sys.exit(1)
    
    def start_all(self):
        """Start all enabled devices"""
        logger.info("üöÄ Starting all devices...")
        
        for device in self.devices:
            if device.enabled:
                device.start()
        
        logger.info(f"‚úÖ All {len([d for d in self.devices if d.enabled])} devices started")
    
    def stop_all(self):
        """Stop all devices"""
        logger.info("‚èπÔ∏è  Stopping all devices...")
        
        for device in self.devices:
            device.stop()
        
        logger.info("‚úÖ All devices stopped")
    
    def print_status(self):
        """Print current status"""
        print("\n" + "=" * 60)
        print(f"üìä IoT Emulator Status - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 60)
        
        for device in self.devices:
            status = "üü¢ RUNNING" if device.running else "üî¥ STOPPED"
            protocols = ", ".join(device.protocols)
            print(f"{status} | {str(device):45} | {protocols}")
        
        print("=" * 60 + "\n")
    
    def run(self, duration=None):
        """Run emulator"""
        try:
            self.load_config()
            self.start_all()
            
            if duration:
                logger.info(f"‚è±Ô∏è  Running for {duration} seconds...")
                time.sleep(duration)
                self.stop_all()
            else:
                logger.info("‚úÖ Emulator running (Ctrl+C to stop)...")
                
                # Show status periodically
                try:
                    while True:
                        time.sleep(60)
                        self.print_status()
                except KeyboardInterrupt:
                    logger.info("\nüõë Interrupt received, stopping...")
                    self.stop_all()
        
        except KeyboardInterrupt:
            logger.info("\nüõë Interrupt received, stopping...")
            self.stop_all()
        except Exception as e:
            logger.error(f"‚ùå Fatal error: {e}", exc_info=True)
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="IoT Device Emulator for Palo Alto SD-WAN/IoT Security Lab"
    )
    parser.add_argument(
        "-c", "--config",
        default="iot_devices.json",
        help="Path to device configuration file (default: iot_devices.json)"
    )
    parser.add_argument(
        "-i", "--interface",
        default="eth0",
        help="Network interface to use (default: eth0)"
    )
    parser.add_argument(
        "-d", "--duration",
        type=int,
        help="Run duration in seconds (default: infinite)"
    )
    parser.add_argument(
        "-s", "--status",
        action="store_true",
        help="Print status and exit"
    )
    
    args = parser.parse_args()
    
    emulator = IoTEmulator(args.config, interface=args.interface)
    
    if args.status:
        emulator.load_config()
        emulator.print_status()
    else:
        emulator.run(duration=args.duration)


if __name__ == "__main__":
    main()

